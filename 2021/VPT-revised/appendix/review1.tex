
\subsection*{Review 1}

I'm mostly satisfied with the revision of the paper. Readability
has been improved and several points have been clarified.
Nevertheless, the paper has still some weaknesses:

\begin{itemize}
  \item The partial deduction algorithm is only informally specified.
  Now it's clearer than in the previous version, but there are
  several functions (e.g., residualize) which are only briefly
  mentioned. Unfortunately, a better formalization is left as
  future work.
  \item The experimental evaluation is somehow limited, since only
  two examples are considered (including several variants of these
  examples). Moreover, the authors compare with a partial evaluator
  for Prolog (ECCE), so one wonders if the comparison is indeed fair.
  Nevertheless, the authors present the first partial evaluator for
  MiniKanren (to the best of my knowledge), so it's understandable
  that there are no other systems to compare with in a fair way.
\end{itemize}

All in all, I think that the paper presents an interesting
development and can be accepted for the post-proceedings.

Some minor remarks:

\begin{itemize}
  \item Abstract: at the early stages $\rightarrow$ at an early stage
  \item Section 2.1: plays a role of a query $\rightarrow$ plays the role of a query
  \item When explaining the operational semantics of MiniKanren, I'm a bit
  confused with item 3 (page 3). It seems to say that conjunctions are
  run from left to right. Is that true? I understood that conjuncts
  can be run in any order during evaluation.

  \todo{\emph{Operational semantics of \mk employs interleaving to achieve completeness of the search: see the last paragraph in~\ref{mkIntro}.
  The denotational semantics of the languages disregards the order in which conjuncts are executed, and this semantics is equivalent to the operational semantics (modulo the order in which answers are computed) see~\cite{rozplokhas2020certified} for details.}}
  \item Page 5: SLDNF tree, then a residual... $\rightarrow$ SLDNF tree; then, a residual...
  \item Page 5: once for one local control tree $\rightarrow$ once for each local control tree
  \item Figure 2: function drive_conj has two arguments (a conjunction
  and a substitution) but, apparently, it's called in line 5 with only
  one argument (the conjunction). Shall perhaps this call include a second
  argument with an empty substitution?

  \todo{\emph{Fixed, also improved the description of the pseudocode in text.}}
  \item Page 7: please explain informally what transient nodes are. E.g., you
  could mention that they would correspond to intermediate functions in
  residual programs that are thus not necessary.
  \item Section 6: for Prolog programming language $\rightarrow$ for the Prolog
  programming language
  \item Section 6: programs, written in miniKanren $\rightarrow$ programs written in miniKanren
  \item Section 6.1: the way the eval is implemented $\rightarrow$ the way eval is implemented
  \item Section 6.1.2: which is, in turn, has a $\rightarrow$ which, in turn, has a
  \item Section 7: techniques for relational... $\rightarrow$ techniques for the relational...
  \item Acknowledgements: discussiona $\rightarrow$ discussions
  \item References [16] and [17] are incomplete. [16] is Michael's Phd thesis, see:

  \url{https://limo.libis.be/primo-explore/fulldisplay?docid=LIRIAS1654943&context=L&vid=Lirias&search_scope=Lirias&tab=default_tab&lang=en_US&fromSitemap=1}

  As for [17], it was actually presented in a Workshop of ILPS'97.
  Anyway, I suggest you consider this more recent reference:

  \begin{verbatim}
    @inproceedings{DBLP:conf/pepm/LeuschelEVCF06,
    author    = {Michael Leuschel and
                 Daniel Elphick and
                 Mauricio Varea and
                 Stephen{-}John Craig and
                 Marc Fontaine},
    editor    = {John Hatcliff and
                 Frank Tip},
    title     = {The Ecce and Logen partial evaluators and their web interfaces},
    booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN} Workshop on Partial Evaluation
                 and Semantics-based Program Manipulation, 2006, Charleston, South
                 Carolina, USA, January 9-10, 2006},
    pages     = {88--94},
    publisher = {{ACM}},
    year      = {2006},
    url       = {https://doi.org/10.1145/1111542.1111557},
    doi       = {10.1145/1111542.1111557},
    timestamp = {Tue, 06 Nov 2018 16:57:57 +0100},
    biburl    = {https://dblp.org/rec/conf/pepm/LeuschelEVCF06.bib},
    bibsource = {dblp computer science bibliography, https://dblp.org}
  }
  \end{verbatim}

\end{itemize}