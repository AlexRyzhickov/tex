\documentclass[12pt]{article}
\usepackage[left=2cm,right=2cm,top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{cmap}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{verbatim}

\pagenumbering{gobble}

\begin{document}

\begin{center}
{\LARGE Формальные языки}

{\Large Индивидуальное домашнее задание для Н. Козубаева}

{\large 29.10.2018}
\end{center}

\bigskip

\begin{enumerate}
  \item Доказать или опровергнуть следующее свойство языков: $( M \cup N ) \cdot L = M \cdot L \cup N \cdot L $ для произвольных языков $L, M, N$.

  \item Построить минимальный детерминированный конечный автомат, распознающий язык  \[ \{ a,b,c \}^+ \ \setminus \ ( \{a^n \mid n \geq 0\} \cup \{c^n \mid n \geq 0\})\]


  \item Построить регулярную грамматику, задающую язык \[\{ a \cdot \alpha \cdot a b \cdot \beta \cdot b b \mid \alpha, \beta \in \{ a, b \}^* \} \cap \{a a \cdot \gamma \cdot b b \cdot \delta \cdot b \mid \gamma, \delta \in \{a, b\}^* \} \]
  \item Проверить регулярность языка (если регулярный, построить автомат, регулярное выражение или регулярную грамматику, иначе --- доказать нерегулярность)
  \[ \{ a^k \omega b^k \mid k \geq 0, \omega \in \{a,b\}^*,|\omega|_a \leq 3 \} \]
  \item {Построить недетерминированный автомат по регулярному выражению $ a^* b a^+ b a^* (b a^* \mid \varepsilon) $, построить эпсилон-замыкание автомата }
  \item {Используя любой понравившийся способ писать парсер, реализовать синтаксический анализатор для подмножества языка пролог, описание которого приведено ниже.}

\end{enumerate}

\begin{center}
  {\Large Описание синтаксиса}
\end{center}
\begin{itemize}
  \item Лексический синтаксис
  \begin{itemize}
    \item Идентификатор --- последовательность букв латинского алфавита в любом регистре, цифр и символа нижнего подчеркивания (\verb!_!), начинающаяся на букву латинского алфавита в нижнем регистре.
    \begin{itemize}
      \item Корректные идентификаторы: \verb!x!, \verb!list!, \verb!listNat_123!.
      \item Некорректные идентификаторы: \verb!Abc!, \verb!123!, \verb!_List!.
    \end{itemize}
    \item Переменная --- последовательность букв латинского алфавита в любом регистре, цифр и символа нижнего подчеркивания (\verb!_!), начинающаяся на букву латинского алфавита в верхнем регистре.
    \begin{itemize}
      \item Корректные переменные: \verb!X!, \verb!XyZ!, \verb!ABC!.
      \item Некорректные переменные: \verb!abc!, \verb!123!, \verb!X Y!.
    \end{itemize}
    \item Ключевые слова: \verb!module!, \verb!type! --- не могут быть идентификаторами.
    \item Другие символы, которые есть в алфавите: штопор \verb!:-!, стрелка \verb!->!, точка \verb!.!, запятая \verb!,!, точка с запятой \verb!;!, вертикальная черта \verb!|!, скобки \verb!(! и \verb!)!.
  \end{itemize}
  \item Базовый синтаксис
      \begin{itemize}
        \item Программа на прологе начинается с \emph{объявления модуля}, за которым идет последовательность \emph{определений отношений}.
        \item Объявление модуля это ключевое слово \verb!module!, за которым идет идентификатор (не переменная), завершается все это точкой \verb!.!: \verb!module example.!
        \item Определение отношения состоит из \emph{головы} и \emph{тела}, разделенных штопором (\verb!:-!), в конце стоит точка (\verb!.!). \emph{Перед} определением отношения может быть приведено \emph{определение его типа} (а может не быть).
        \item Голова отношения --- атом.
        \item Атом --- идентификатор, за которым в скобках (\verb!(!, \verb!)!) идет последовательность атомов или переменных, разделенных запятыми (\verb!,!).
        \item У атома может не быть аргументов, тогда он имеет вид идентификатора (без пустых скобок).
        \item Тело отношения --- выражение с правоассоциативными бинарными операторами конъюнкции (\verb!,!) и дизъюнкции (\verb!;!) над атомами. Конъюнкция имеет более высокий приоритет, чем дизъюнкция. Возможно использование скобок (\verb!(!, \verb!)!) для управления порядком вычислений.
        \item Тело и штопор могут отсутствовать (вместе).
        \item Где угодно могут встречаться пробельные символы: советую использовать лексер.
        \item Определение типа это строка, начинающаяся с ключевого слова \verb!type!, за которым идет идентификатор-имя типа, за которым идет тип, в конце -- точка \verb!.!. Тип это последовательность атомов, переменных или типов, разделенных стрелкой \verb!->!.
          \begin{itemize}
            \item Корректные определения типов
            \begin{itemize}
              \item \verb!type filter (A -> o) -> list(A) -> list(A) -> o.!
              \item \verb!type fruit string -> o.!
            \end{itemize}
            \item Некорректные определения типов
            \begin{itemize}
              \item \verb!type type type -> type.! --- ключевое слово используется как идентификатор
              \item \verb!type lst list nat.! --- \verb!list nat! не является корректным типом
              \item \verb!type x -> y -> z.! --- нет имени типа
              \item \verb!tupe x o.! --- идентификатор вместо ключевого слова \verb!type!
            \end{itemize}
          \end{itemize}

        \item Синтаксический сахар для списков:
        \begin{itemize}
          \item Список это возможно пустая последовательность атомов или переменных, разделенных запятой (\verb!,!), находящаяся в квадратных скобках (\verb![!, \verb!]!).
          \begin{itemize}
            \item Корректные списки: \verb![]!, \verb![X, Y, Z]!, \verb![a(b(c)), d, Z]!.
            \item Некорректные списки: \verb![!, \verb!]a, b, c[!
          \end{itemize}

          \item Можно специфицировать список, состоящий из головы \verb!H! и хвоста \verb!T!: \verb![H|T]!. В голове может быть не только переменная, но и произвольный атом, хвост --- обязательно переменная.
          \begin{itemize}
            \item Корректные списки: \verb![H | T]!, \verb![a(b(c)) | T]!
            \item Некорректные списки: \verb![H | abc]!, \verb![H | A(b, c)]!
          \end{itemize}
          \item Комбинация двух предыдущих способов: несколько первых элементов через запятую, дальше \verb!|!, дальше переменная.
          \begin{itemize}
            \item Корректные списки: \verb![H, H1 | T]!, \verb![a(b(c)), Second, Third | T]!
            \item Некорректные списки: \verb![H, | abc]!, \verb![ | A]!
          \end{itemize}
          \item Список может вкладываться в другой список: \verb![[X, [H | T]] | Z]!
          \item Список не может быть головой атома, но может быть аргументом.
          \begin{itemize}
            \item Некорректное использование списка: \verb![X](Y) :- f(X, Y).!
            \item Корректное использование списка: \verb!g([X], Y) :- f(X, Y).!
          \end{itemize}
          \item Важно: это синтаксический сахар, он не должен добавлять новые сущности в абстрактный синтаксис.
          \begin{itemize}
            \item \verb![X, Y | T]! $=$ \verb!cons(X,cons(Y, T))!
            \item \verb![X, Y, Z]! $=$  \verb!cons(X,cons(Y, cons(T, nil)))!
            \item \verb![a(b(c)) | T]! $=$ \verb!cons(a(b(c)), T)!
          \end{itemize}
        \end{itemize}
      \end{itemize}
      \item Примеры корректных определений отношений.
      \begin{itemize}
        \item \verb!f.!
        \item \verb!f :- g.!
        \item \verb!f :- g, h; t.!
        \item \verb!f :- g, (h; t).!
        \item \verb!f(a) :- g, h(t, c, d).!
        \item \verb!f(cons(h, t)) :- g(h), f(t).!
      \end{itemize}
      \item Примеры некорректных определений отношений.
      \begin{itemize}
        \item \verb!f! --- нет точки.
        \item \verb!:- f.! --- нет головы.
        \item \verb!f :- .! --- нет тела.
        \item \verb!f :- g; h, .! --- нет правого подвыражения у конъюнкции.
        \item \verb!f :- (g; (f).! --- несбалансированные скобки.
        \item \verb!f ().! --- пустые скобки
      \end{itemize}
      \item Требования к оформлению
      \begin{itemize}
        \item Результатом должно быть консольное приложение, которое принимает на вход программу и печатает результат синтаксического анализа в файл с таким же названием и дополнительным расширением \verb!.out!. (\verb!input.txt! $\to$ \verb!input.txt.out!)
        \item Результатом синтаксического анализа является абстрактное синтаксическое дерево в случае успешного разбора и сообщение об ошибке иначе.
        \begin{itemize}
          \item Если произошла лексическая ошибка, то сообщить о ней и завершиться, не пытаясь дальше парсить.
          \item Если произошла любая ошибка --- сообщить о ней и завершиться, не пытаясь восстанавливаться после ошибке.
        \end{itemize}
        \item Код может быть написан на любом языке программирования с использованием любых инструментов, но должен быть сопровожден инструкцией по сборке и запуску. Желательно выложить его на гитхаб и сопроводить тестами.
      \end{itemize}

    \end{itemize}
\end{document}
