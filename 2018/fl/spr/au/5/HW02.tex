\documentclass{article}

\usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{euscript}
\usepackage{hyperref}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}

\lstdefinelanguage{llang}{
keywords={skip, do, while, read, write, if, then, else, begin, end},
sensitive=true,
%%basicstyle=\small,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}1
}

\lstset{
language=llang
}

\newcommand{\aset}[1]{\left\{{#1}\right\}}
\newcommand{\term}[1]{\mbox{\texttt{\bf{#1}}}}
\newcommand{\cd}[1]{\mbox{\texttt{#1}}}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\conf}[1]{\left<{#1}\right>}
\newcommand{\fancy}[1]{{\cal{#1}}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\xrightarrow{#2}{#3}}
\newcommand{\ctrans}[4]{{#1}\xrightarrow{#2}{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
\newcommand{\ruleno}[1]{\eqno[\textsc{#1}]}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}

\newcommand{\NN}{\mathbb N}
\newcommand{\ZZ}{\mathbb Z}

\begin{document}

%% Весь этот текст можно удалить
%% ====== от сих =====
\begin{center} {\LARGE Формальные языки} \end{center}

\begin{center} {\Large домашнее задание до 23:59 01.04} \end{center}
\bigskip

\begin{enumerate}
  \item Написать лексер для языка L (спецификация ниже), используя любимый инструмент (например, генератор лексеров из семейства Lex, ANTLR, парсер-комбинаторы, написать вручную...). (8 баллов за полностью выполненное задание)
    \begin{itemize}
        \item Структуры данных для лексем должны однозначно их идентифицировать, а также содержать привязку к коду (в какой строке исходного кода и с какого по какой символ располагается лексема). 
        \item Составить набор тестов, демонстрирующий правильность работы полученного лексера (качество тестового покрытия важно!).
        \item Сделать консольное  приложение, принимающее на вход путь к файлу, содержащему программу на языке L, производящее лексический анализ и печатающее полученный поток лексем.
        \begin{itemize}
            \item Результатом работы лексического анализатора должен быть поток лексем, который печатается при помощи \emph{отдельной} процедуры печати. 
        \end{itemize}
        \item Код должен быть размещен на гитхабе, собираться одним скриптом, содержать инструкцию по сборке и запуску собранного приложения, собираться на чистой Ubuntu 16.04 или Windows 10. Все зависимости, в случае их отсутствия в системе, должны доставляться скриптом.
        \begin{itemize}
            \item Инструкция по запуску должна содержать информацию о том, где находится бинарник, как именно его полагается запускать, какой формат аргументов командной строки, куда пишется результат.
        \end{itemize} 
     \end{itemize}
  \item Предложить удобный конкретный синтаксис для языка L (абстрактный синтаксис приведен ниже, будьте внимательны, он немного отличается от того, что был на паре) --- описать в pdf. (2 балла)
  \begin{itemize}
    \item Удобность тут понятие относительное --- какой вам синтаксис нравится, такой и используйте.
    \item Какие есть варианты. Разделять ли операторы языка разделителями или сделать значимыми переносы строк и отсупы? Использовать скобки для группировки блоков кода, ключевые слова begin/end или маркеры конца блока, зависящие от того, в контексте какого оператора мы находимся? Использовать ли скобки для аргументов функций? Может вы хотите предоставить синтаксический сахар для облегчения синтаксиса? 
  \end{itemize}
  \item \emph{Это задание на через пару, но его полезно учитывать при разработке лексера и конкретного синтаксиса.} Написать парсер для предложенного конкретного синтаксиса языка L (описание языка ниже), используя любимый способ писать парсеры. Не забыть про тесты (8 баллов)
    \begin{itemize}
        \item Можно реализовать любой понравившийся вам алгоритм синтаксического анализа.
        \item Можно пользоваться парсер-комбинаторами, можно даже реализовать свою библиотеку.
        \item Можно использовать генераторы синтаксических анализаторов (yacc, bison, antlr, любой другой).
        \item Желательно, чтобы ваш синтаксический анализатор принимал на вход то, что выдает ваш лексер --- те самые токены с позициями во входной строке; если для этого нужно править лексер --- правьте. Если технологии не сочетаются, реализовать функциональность лексического анализа, как требуется в вашем случае.
        \item Создайте консольное приложение для запуска синтаксического анализа.
        \begin{itemize}
            \item Консольное приложение обязательно должно принимать адрес файла со входной программой
            \item Программа может быть многострочной
            \item Результатом синтаксического анализа должно быть \emph{абстрактное синтаксическое дерево}, напечатанное в человекочитаемом формате; можно в файл, но название файла должно быть связано с названием входного файла (можно в dot).
            \item Лексемы в дереве вывода должны отображаться со всей необходимой информацией (тип лексемы, значение и привязка к коду).
            \item Код должен быть размещен на гитхабе, собираться одним скриптом, содержать инструкцию по сборке и запуску собранного приложения, собираться на чистой Ubuntu 16.04 или Windows 10. Все зависимости, в случае их отсутствия в системе, должны доставляться скриптом.
        \end{itemize}
     \end{itemize}
\end{enumerate}

\newpage

\begin{center} {\Large Лексическая спецификация языка L } \end{center}

\medskip

Программы на языке L записываются символами ASCII. Ограничителями строк являются ASCII-символы CR, LF или 2 подряд идущих символа: CR LF. Пробельными символами являются символы-ограничители строк и символы пробела (SP), табуляции (HT) и перевода страницы (FF). Пробельные символы не имеют значения, для них не должно генерироваться лексем. Все буквы строчные. Программы могут быть многострочными. 

Комментарии пока только однострочные. Комментарием считается суффикс строки до символа-ограничителя строк, начинающийся с "//".

Идентификаторы в языке --- произвольная последовательность символов латинского алфавита, цифр и символа подчеркивания (\_) (до первого пробельного символа, разделителя или оператора), начинающаяся либо с буквы, либо символа подчеркивания, которая не является ключевым словом или литералом. 

Ключевые слова языка: $\llang{if}, \llang{then}, \llang{else}, \llang{while}, \llang{do}, \llang{read}, \llang{write}$

Литералы языка: числа с плавающей точкой, \llang{true}, \llang{false}. 

Числа с плавающей точкой должны соответствовать спецификации языка Java (\href{https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10}{по ссылке}): обратите внимание на подчеркивания. В лексеме для числа должно присутствовать его значение --- численного типа, не строковое представление.

Операторы языка: $ \llang{+}, \llang{-}, \llang{*}, \llang{/}, \llang{\%}, \llang{==}, \llang{!=}, 
\llang{>}, \llang{>=}, \llang{<}, \llang{<=}, \llang{\&\&}, \llang{||}
$

Разделители языка: $(, \, ), \, ; $ 

Пример программы (в каком-то конкретном синтаксисе): 
$$
\llang{read}\; x \llang{;} \; \llang{if} \; y + 1 == x  \; \llang{then} \; \llang{write} \; y \; \llang{else} \; \llang{write} \; x \;  
$$

Результат лексического анализа должен быть в духе: 

\begin{verbatim}
KW_Read(0, 0, 3); Ident("x", 0, 5, 5); Colon(0, 6, 6); KW_If(0, 8, 9); Ident("y", 0, 11, 11);
Op(Plus, 0, 13, 13); Num(1, 0, 15, 15); Op(Eq, 0, 17, 18); Ident("x", 0, 20, 20); KW_Then(0, 22, 25); 
KW_Write(0, 27, 31); Ident("y", 0, 33, 33); KW_Else(0, 35, 38); KW_Write(0, 40, 44); Ident("x", 0, 46, 47);
\end{verbatim}

\bigskip

\centering {\Large Абстрактный синтаксис языка L }
$$
X \mbox{ --- счетно-бесконечное множество идентификаторов}
$$
$$
\otimes=\{\llang{+}, \llang{-}, \llang{*}, \llang{/}, \llang{\%}, \llang{==}, \llang{!=}, 
\llang{>}, \llang{>=}, \llang{<}, \llang{<=}, \llang{\&\&}, \llang{||}\}
$$

\begin{itemize}
\item Определения (функций): $\fancy{D}=\fancy{X}_{name} \; \fancy{X}_0 \dots \fancy{X}_k \leftarrow \fancy{S}$. $\fancy{X}_{name}$ --- имя функции;  $\fancy{X}_0 \dots \fancy{X}_k$ --- ее аргументы; $\fancy{S}$~--- тело.
\item Вызовы функций: $\fancy{C} = \fancy{X}_{name} \; \fancy{E}_0 \dots \fancy{E}_k$. \emph{Аргументами могут быть произвольные выражения.}
\item Выражения: $\fancy{E}=\fancy{C} \cup X\cup\NN\cup(\fancy{E}\otimes\fancy{E})$. \emph{Вызовы функций могут быть использованы в выражениях.} В выражениях могут использоваться круглые скобки.


\item Операторы: 

$$
\begin{array}{rll}
  \fancy{S}=
            &\fancy{X}\;\llang{:=}\;\fancy{E}&\cup\\
            &\fancy{C}&\cup\\
            &\llang{write}\;\fancy{E}&\cup\\
            &\llang{read}\;\fancy{X}&\cup\\
            &\llang{while}\;\fancy{E}\;\llang{do}\;\fancy{S}&\cup\\
            &\llang{if}\;\fancy{E}\;\llang{then}\;\fancy{S}\;\llang{else}\;\fancy{S}&\cup\\
            &\fancy{S}^* \, \emph{(Последовательность операторов)}
            
\end{array}
$$
\item Программы: $\fancy{P}=(\fancy{D}^*, \fancy{S})$ --- несколько определений, за которыми следует текст самой программы
\end{itemize}
\end{document}

