\documentclass[12pt]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{fontspec}
\usepackage{polyglossia}
\usepackage{amssymb}
\setdefaultlanguage{russian}
\setmainfont[Mapping=tex-text]{CMU Serif}

\begin{document}
\centering {\LARGE Формальные языки}

{\Large домашнее задание до 23:59 17.09}
\bigskip

\enumerate
{
  \item 
  { 
    Построить детерминированные \textbf{полные} конечные автоматы (если надо, добавить ``дьявольскую'' вершину) и представить описание в виде множества для следующих языков над алфавитом $\Sigma = \{ a, b, c \}$:
    \begin{enumerate}
        \item каждое слово языка содержит подслово $bcc$ или $bba$;
        \item слова заканчиваются всегда на другую букву, чем та, на которую они начинаются;
        \item  буква $c$ не встречается ``левее'' буквы $b$ ни в одном слове
    \end{enumerate}
  }
  \item
  {
    Минимизировать каждый из автоматов в предыдущем задании. Если автомат уже минимален, доказать это. 
  }
  \item 
  {
    Реализовать алгоритм минимизации конечных автоматов. 
        \begin{itemize}
        \item Сделать консольное  приложение, принимающее на вход путь к файлу, содержащему описание конечного автомата, производящее минимизацию и печатающее его результат в файл.
        \begin{itemize}
            \item Результатом работы минимизации является минимальный эквивалентный данному конечный автомат. Если автомат уже минимален, минимизация его не изменяет.
        \end{itemize}
        \item Составить набор тестов, демонстрирующий правильность работы реализации (качество тестового покрытия важно!).
        \item Код должен быть размещен на гитхабе, собираться одним скриптом, содержать инструкцию по сборке и запуску собранного приложения, собираться на чистой Ubuntu 18.04 или Windows 10. Все зависимости, в случае их отсутствия в системе, должны доставляться скриптом.
        \begin{itemize}
            \item Инструкция по запуску должна содержать информацию о том, где находится бинарник, как именно его полагается запускать, какой формат описания автомата, куда пишется результат.
            \item Можно писать на любом языке программирования. 
        \end{itemize} 
     \end{itemize}
  }
  
\newpage
\begin{center} \Large{Пример применения алгоритма минимизации}
\end{center}

\bigskip

Минимизируем данный автомат:

\begin{center} \includegraphics[width=0.65\linewidth]{../../2016_win/ElTech/2exmin.png} \end{center}

Автомат полный, в нем нет недостижимых вершин --- продолжаем.

Строим обратное $\delta$ отображение. 

\begin{tabular}{c|c|c}
$\delta^{-1}$ & 0 & 1 \\ \hline
A & --- & B \\
B & --- & A \\
C & A B & --- \\
D & C & C \\
E & D & --- \\
F & E F & D F G \\
G & G & E 
\end{tabular}

Отмечаем в таблице и добавляем в очередь пары состояний, различаемых словом $\varepsilon$: все пары, один элемент которых --- терминальное состояние, а второй --- не терминальное состояние. Для данного автомата это пары 

$(A, F), (B, F), (C, F), (D, F), (E,F), (A, G), (B, G), (C, G), (D, G), (E, G)$

Дальше итерируем процесс определения неэквивалентных состояний, пока очередь не оказывается пуста. 

$(A, F)$ не дает нам новых неэквивалентных пар. Для $(B, F)$ находится 2 пары: $(A, D), (A, G)$. Первая пара не отмечена в таблице --- отмечаем и добавляем в очередь. Вторая пара уже отмечена в таблице, значит, ничего делать не надо. Переходим к следующей паре из очереди. Итерируем дальше, пока очередь не опустошится. 

Результирующая таблица (заполнен только треугольник, потому что остальное симметрично) и порядок добавления пар в очередь.

\begin{tabular}{c|cc|cc|cc|c}
& A & B & C & D & E & F & G \\ \hline
A &&&&&&& \\
B &&&&&&& \\ \hline
C & \checkmark & \checkmark &&&&& \\
D & \checkmark & \checkmark & \checkmark &&&& \\ \hline
E & \checkmark & \checkmark & \checkmark & \checkmark &&& \\
F & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark && \\ \hline
G & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark && \\
\end{tabular}

Очередь: 

$
(A, F), (B, F), (C, F), (D, F), (E,F), (A, G), (B, G), (C, G), (D, G), (E, G),
$

$
(B, D), (A, D), (A, E), (B, E), (C, E), (C, D), (D, E), (A,C), (B, C))
$

В таблице выделились классы эквивалентных вершин: $\{A, B\}, \{C\}, \{D\}, \{E\}, \{F,G\}$. Остается только нарисовать результирующий автомат с вершинами-классами. Переходы добавляются тогда, когда из какого-нибудь состояния первого класса есть переход в какое-нибудь состояние второго класса. Минимизированный автомат: 

\includegraphics[width=0.65\linewidth]{../../2016_win/ElTech/2exminres.png}

\end{document}
