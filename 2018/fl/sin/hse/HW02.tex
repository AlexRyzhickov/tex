\documentclass{article}

\usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{euscript}
\usepackage{hyperref}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}

\begin{document}

%% Весь этот текст можно удалить
%% ====== от сих =====
\begin{center} {\LARGE Формальные языки} \end{center}

\begin{center} {\Large домашнее задание до 23:59 20.09} \end{center}
\bigskip

\begin{enumerate}
  \item Построить минимальный конечный автомат, распознающий язык натуральных чисел в десятичной системе без лидирующих нулей, деляющихся на $4$ и имеющих сумму цифр, равную $2$.
  \item Построить минимальный конечный автомат, распознающий язык \\ $ L = \{ \alpha \cdot a b a \cdot \beta \mid \alpha, \beta \in \{ a, b \}^* \} \cup \{ \alpha \cdot b a b \cdot \beta \mid \alpha, \beta \in \{ a, b \}^* \} $
  \item Найти описание лексической структуры вашего второго самого любимого языка программирования. Составить минимальные (!) конечные автоматы для трех языков: языка идентификаторов, языка ключевых слов (можно какого-нибудь их конечного подмножества) и языка каких-нибудь чисел (целых в десятичной счисления, с плавающей точкой, любых других). В отчете указать, где и какую спецификацию читали и привести автоматы (их должно быть три). 
  \item 
  {
    Реализовать алгоритм минимизации конечных автоматов. (3 балла)
        \begin{itemize}
        \item Сделать консольное  приложение, принимающее на вход путь к файлу, содержащему описание конечного автомата, производящее минимизацию и печатающее его результат в файл.
        \item Результатом работы минимизации является минимальный эквивалентный данному конечный автомат. Если автомат уже минимален, минимизация его не изменяет.
        \item Желательно отрисовывать конечный автомат в виде графа --- тут можно пользоваться библиотеками для визуализации, например, \verb!graphviz!.
        \item Составить набор тестов, демонстрирующий правильность работы реализации (качество тестового покрытия важно!).
        \item Код должен быть размещен на гитхабе, собираться одним скриптом, содержать инструкцию по сборке и запуску собранного приложения, собираться на чистой Ubuntu 18.04 или Windows 10. Все зависимости, в случае их отсутствия в системе, должны доставляться скриптом.
        \begin{itemize}
            \item Инструкция по запуску должна содержать информацию о том, где находится бинарник, как именно его полагается запускать, какой формат описания автомата, куда пишется результат.
            \item Можно писать на любом языке программирования. 
        \end{itemize} 
     \end{itemize}
  }
\end{enumerate}
\newpage
\begin{center} \Large{Пример применения алгоритма минимизации}
\end{center}

\bigskip

Минимизируем данный автомат:

\begin{center} \includegraphics[width=0.65\linewidth]{../../2016_win/ElTech/2exmin.png} \end{center}

Автомат полный, в нем нет недостижимых вершин --- продолжаем.

Строим обратное $\delta$ отображение. 

\begin{tabular}{c|c|c}
$\delta^{-1}$ & 0 & 1 \\ \hline
A & --- & B \\
B & --- & A \\
C & A B & --- \\
D & C & C \\
E & D & --- \\
F & E F & D F G \\
G & G & E 
\end{tabular}

Отмечаем в таблице и добавляем в очередь пары состояний, различаемых словом $\varepsilon$: все пары, один элемент которых --- терминальное состояние, а второй --- не терминальное состояние. Для данного автомата это пары 

$(A, F), (B, F), (C, F), (D, F), (E,F), (A, G), (B, G), (C, G), (D, G), (E, G)$

Дальше итерируем процесс определения неэквивалентных состояний, пока очередь не оказывается пуста. 

$(A, F)$ не дает нам новых неэквивалентных пар. Для $(B, F)$ находится 2 пары: $(A, D), (A, G)$. Первая пара не отмечена в таблице --- отмечаем и добавляем в очередь. Вторая пара уже отмечена в таблице, значит, ничего делать не надо. Переходим к следующей паре из очереди. Итерируем дальше, пока очередь не опустошится. 

Результирующая таблица (заполнен только треугольник, потому что остальное симметрично) и порядок добавления пар в очередь.

\begin{tabular}{c|cc|cc|cc|c}
& A & B & C & D & E & F & G \\ \hline
A &&&&&&& \\
B &&&&&&& \\ \hline
C & \checkmark & \checkmark &&&&& \\
D & \checkmark & \checkmark & \checkmark &&&& \\ \hline
E & \checkmark & \checkmark & \checkmark & \checkmark &&& \\
F & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark && \\ \hline
G & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark && \\
\end{tabular}

Очередь: 

$
(A, F), (B, F), (C, F), (D, F), (E,F), (A, G), (B, G), (C, G), (D, G), (E, G),
$

$
(B, D), (A, D), (A, E), (B, E), (C, E), (C, D), (D, E), (A,C), (B, C))
$

В таблице выделились классы эквивалентных вершин: $\{A, B\}, \{C\}, \{D\}, \{E\}, \{F,G\}$. Остается только нарисовать результирующий автомат с вершинами-классами. Переходы добавляются тогда, когда из какого-нибудь состояния первого класса есть переход в какое-нибудь состояние второго класса. Минимизированный автомат: 

\includegraphics[width=0.65\linewidth]{../../2016_win/ElTech/2exminres.png}

\end{document}

