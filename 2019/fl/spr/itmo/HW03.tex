\documentclass{article}

\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{euscript}
\usepackage{hyperref}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}

\begin{document}

\begin{center} {\LARGE Формальные языки} \end{center}

\begin{center} {\Large домашнее задание до 23:59 27.02} \end{center}
\bigskip

Шаблон кода для задания живет в соответсвующей ветке: 

\href{https://github.com/kajigor/fl_ifmo_2019_spr/tree/HW03}{https://github.com/kajigor/fl\_ifmo\_2019\_spr/tree/HW03}

\begin{enumerate}
  \item 
  {
    Реализовать парсер-комбинатор, который парсит список в общем виде, возвращая список элементов. 
    
    \verb!parseList elem delim lbr rbr minimumNumberElems!
    
    \verb!elem! --- парсер для элемента.
    
    \verb!delim! --- парсер для разделителя.
    
    \verb!lbr! --- парсер для открывающейся скобки.
    
    \verb!rbr! --- парсер для закрывающейся скобки.
    
    \verb!minimumNumberElems! --- минимальное количество элементов, которые должны быть в списке.
    
    Учтите, что скобки и разделители могут быть призвольного вида, не обязательно одинокими символами.
    
    Между элементами, разделителями и скобками может быть любое количество пробельных символов: пробелов, переносов строк, табуляций.
  }
  \item
  {
    Реализовать парсер для автоматов. Используйте вашу реализацию комбинаторов, добавлять новые, конечно же, не запрещено.
    
    На вход принимает строку, на выход возвращает может быть автомат. Эта функция может не проверять автомат на корректность --- только парсить синтаксическую структуру и возвращать \verb!Just! значение типа \verb!Automaton s q!, если синтаксических ошибок нет, и \verb!Nothing! иначе. Если вы хотите сразу проверять автомат еще и на корректность, можно не городить 2 разных парсера, а сразу реализовывать следующее задание. 
    
    Формат входа: 
    
    \begin{itemize}
        \item Описание автомата состоит из 5 списков, разделенных запятыми. Элементы в списках разделяются запятыми, скобки треугольные. Пока предполагаем, что запятые и скобки не могут быть ни символами алфавита, ни состояниями. 
        
        \item Порядок такой: 
        
        \begin{itemize}
            \item Список символов 
            \item Список состояний
            \item Список из одного состояния --- стартового
            \item Список терминальных состояний
            \item Список троек: \verb!(состояние, символ, состояние)! --- в круглых собках через запятую
        \end{itemize}
    \end{itemize}
    
  }
  \item
  {
    Реализовать проверку автомата на корректность. Проверки должны выполняться как можно раньше: если начальное состояние не является элементом списка состояний, то список терминальных состояний не должен быть прочитан. 
    
    Если не получается встроить проверки непосредственно в процесс анализа, реализуйте отдельную функцию проверки, которая принимает сам автомат. 
    
  }
\end{enumerate}


    Если вы не хотите писать на Haskell, реализуйте похожую на нашу библиотечку комбинаторов и используйте ее. Правила оформления работы остаются с прошлого домашнего задания.
\end{document}

